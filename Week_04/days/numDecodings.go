package days

import "fmt"

// 91. 解码方法
// 思路：
// 1.  如果 i 指向的字符为 ‘0’，看之前的字符是否为 '1' 或 '2'，如果是，那就只有 10 和 20 两个字符，i 和 i-1 只有一种可能
//         递推公式为 dp[i] = dp[i-2]
//     如果之前的字符非上面的情况，则出现了类似 30 的情况，这种情况是不合法的，直接 return 0

// 2.  如果 i 非 0， 看之前的是否为 1 或 2，如果为 2，需要看一下当前的值是否小于等于 6。这样保证数字在 10 ~ 26（剔除 10 和 20）
//         此时，以 23 为例， 它可能是 （2 和 3） 或 23 两种情况
//         故递推公式为 dp[i] = dp[i-1]（2和3的情况） + dp[i-2]（23的情况）
//     除此之外，可能出现的情况只有类似 39（非 10~26 的所有数字） 这种情况，此时只能是 3 或 9，也是一种情况
//         递推公式为 dp[i] = dp[i-1]

// 注意，动态规划的初始化比较麻烦，为了让 dp 数组满足上面的假设（主要是 dp[i] = dp[i-2] 的情况），设置一个没有意义的 dp[0]

// 递推数组的意义：到字符串s[i]为止，合法的方法为 dp[i+1] 个
// 例如 s = "1234"，得到的 dp 数组为 [1     1    2     3      3  ]，
//             他们对应的下标为:          s[0]  s[1]  s[2]   s[3]
//             他们对应的字符串为： 无意义  ‘1’ ‘12’  ‘123’  ‘1234’
func numDecodings(s string) int {
	if s[0] == '0' {
		return 0
	}

	n := len(s)

	dp := make([]int, n+1) // 初始化一个长度为 n+1 的数组
	dp[0] = 1
	dp[1] = 1

	for i := 1; i < n; i++ {
		if s[i] == '0' {
			if s[i-1] == '1' || s[i-1] == '2' { // 10 or 20
				dp[i+1] = dp[i-1]
			} else {
				return 0
			}
		} else {
			if s[i-1] == '1' || (s[i-1] == '2' && s[i] <= '6') { // 10~26，排除 10 和 20
				dp[i+1] = dp[i] + dp[i-1]
			} else { // 其余情况，如 39、28、99 等
				dp[i+1] = dp[i]
			}
		}
	}

	fmt.Println(dp) // 你可以打印 dp 分析一下具体情况

	return dp[n]
}
